







<!DOCTYPE html>

<html>
    
<!-- Mirrored from plausible.coop/blog/2017/09/18/build-with-plrelational-part-1 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Nov 2021 23:08:06 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <title>Let&#x27;s Build with PLRelational, Part 1</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans+Condensed:400|IBM+Plex+Sans:300,400,400i,500,700&amp;display=swap">
        <link rel="stylesheet" media="screen" href="../../../../../assets/stylesheets/main/index.css">
        
    <link rel="stylesheet" media="screen" href="../../../../../assets/stylesheets/blog/index.css">

        <link rel="shortcut icon" type="image/ico" href="../../../../../assets/images/main/favicon/index.ico">
        <script src="../../../../../assets/javascripts/jquery-1.9.0.min/index.js" type="text/javascript"></script>
        <script src="../../../../../assets/javascripts/retina/index.js" type="text/javascript"></script>
        
    <script type='text/javascript' src='../../../../../assets/javascripts/blog/jquery.gifplayer/index.js'></script>
    
    <script>
		$(document).ready( function(){
			$('.gifplayer').gifplayer();
		});
    </script>
    
    
    
    <meta name="twitter:card" content="summary_large_image" />
    
    <meta name="twitter:image:src" content="http://plausible.coop/assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/twitter-card.png" />
    
    
    <meta name="twitter:site" content="@plausiblelabs" />
    <meta name="twitter:creator" content="@chrscmpbll" />
    <meta name="twitter:title" content="Let&#x27;s Build with PLRelational, Part 1" />
    <meta name="twitter:description" content="A big picture look at PLRelational and how it can be used to build a real application using a reactive-relational approach." />
    

    </head>
    <body>
        <header>
            <h3>
                <a href="../../../../..">
                    <img src="../../../../../assets/images/main/clickable-logo-space/index.png" width="34px" height="34px" alt="PL" />
                </a>
            </h3>
            <ul>
                <li><a href="../../../../../software">Open Source</a></li>
                <li><a href="../../../../../portfolio">Portfolio</a></li>
                <li><a href="../../../..">Blog</a></li>
                <li><a href="../../../../../about">About</a></li>
            </ul>
        </header>
            <div id="main">
                
    <div class="blog">

        <div class="main">

            <div class="articles">
                <h1>
                    <a href="#">Let&#x27;s Build with PLRelational, Part 1</a>
                </h1>
                <p class="author">September 18, 2017, by Chris Campbell</p>
                <script>
$(document).ready(function() {
  var pt1regions = {
    'req-link-1': { 'x': 14, 'y': 40, 'w': 302, 'h': 34, 'id': '1' },
    'req-link-2': { 'x': 14, 'y': 74, 'w': 302, 'h': 116, 'id': '2' },
    'req-link-3': { 'x': 30, 'y': 74, 'w': 28, 'h': 116, 'id': '3' },
    'req-link-4': { 'x': 56, 'y': 74, 'w': 132, 'h': 116, 'id': '4' },
    'req-link-5': { 'x': 216, 'y': 74, 'w': 88, 'h': 116, 'id': '5' }
  };
  
  $(".pt1-req-link").click(function(){
      var region = pt1regions[this.id];
      var reqID = region.id;
      $('html, body').animate({
          scrollTop: $( "#req" + reqID + "-head" ).offset().top - 60
      }, 500);
      return false;
  });

  $(".pt1-req-link").hover(
    function(e) {
      var region = pt1regions[this.id];
      
      $("#pt1-blackout").empty();
      $("#pt1-blackout").append(` \
        <svg viewbox="0 0 640 462" width="100%"> \
          <defs> \
            <mask id="mask" x="0" y="0" width="100%" height="100%"> \
              <rect x="0" y="0" width="100%" height="100%" rx="4" ry="4" fill="#fff"/> \
              <rect x="${region.x}" y="${region.y}" width="${region.w}" height="${region.h}" rx="4" ry="4"/> \
            </mask> \
          </defs> \
          <rect x="0" y="0" width="640" height="462" mask="url(#mask)" fill-opacity="0.6"/> \
        </svg> \
      `)
      
      var reqID = region.id;
      var reqHead = $("#req" + reqID + "-head");
      var title = reqHead.find(".req-title").text();
      var desc = reqHead.find(".req-desc").text();
      $("#pt1-req-popup").html("<b>" + title + "</b><br/>" + "<i>" + desc + "</i>");

      $(".pt1-req-link").not(this).hide();
      $("#pt1-blackout").stop(true, true).fadeIn("fast");
      $("#pt1-req-popup").stop(true, true).fadeIn("fast");
    },
    function(e) {
      $(".pt1-req-link").not(this).show();
      $("#pt1-blackout").stop(true, true).fadeOut("fast");
      $("#pt1-req-popup").stop(true, true).fadeOut("fast");
    }
  );
})
</script>
<style>
.pt1-img-container {
  position: relative;
  height: 500px;
  margin-top: 32px;
}
.pt1-img-container img {
  filter: drop-shadow(0px 2px 4px #888);
  margin-left: 14px;
}
.pt1-img-container a {
  position: absolute;
  color: white;
  border-radius: 50%;
  width: 26px;
  height: 26px;
  line-height: 26px;
  background-color: red;
  text-align: center;
  vertical-align: middle;
}
.pt1-img-container .blackout {
  position: absolute;
  width: 640px;
  height: 462px;
  left: 14px;
  top: 0px;
}
a.pt1-req-target {
  display: block;
  position: relative;
  top: -60px;
}
#pt1-req-popup {
  position: relative;
  width: 264px;
  margin-left: 36px;
  margin-top: -250px;
  padding: 10px;
  background-color: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.8em;
}
.pt1-anim-gif-container .gifplayer-wrapper img {
  border: 0px;
}
</style><p><em>This is our latest entry in a series of articles on <a href="https://github.com/plausiblelabs/plrelational">PLRelational</a>. For more background, check out these other articles in the series:</em></p>
<ul>
  <li><em><a href="../../../08/10/reactive-relational-programming-with-plrelational">Reactive Relational Programming with PLRelational</a></em></li>
  <li><em><a href="../../../08/24/intro-to-relational-algebra-using-plrelational">Introduction to Relational Algebra using PLRelational</a></em></li>
  <li><em><a href="../../../08/29/plrelational-observing-change">PLRelational: Observing Change</a></em></li>
  <li><em><a href="../../07/plrelational-storage-formats">PLRelational: Storage Formats</a></em></li>
</ul><p>Since we started opening up about PLRelational, a number of developers have asked us how it compares to some particular existing technology, e.g. Core Data, Rx, Cocoa Bindings, or SQLite. It's a good question, but before we can clearly explain the differences, we should first dissect a working application that was built using PLRelational.</p><p>Our goal with this article is to give a big picture look at PLRelational and how it can be used to build an actual application. We will show how you can do things the <em>PLRelational Way</em>, and that will give us a baseline to help compare and contrast to existing technologies in a future article.</p><p>We believe PLRelational[+Binding] gives you a unique, expressive vocabulary for declaring how your UI is connected. Once you've declared those relationships, the frameworks can do a lot of heavy lifting, simplifying the way you build an application. As we will demonstrate here, there are a few patterns commonly used when working with PLRelational that can help bring a sense of order and sanity to application development. </p><h3>What Should We Build?</h3><p>To get started, we need to think of a relatively constrained type of application to build, and there's no better (or more clich√©d) example than a to-do app, so let's run with that. In a nutshell, our application will allow the user to:</p>
<ul>
  <li>enter new to-do items</li>
  <li>mark an item as completed</li>
  <li>change the item text</li>
  <li>add tags to an item</li>
  <li>add notes for an item</li>
  <li>delete an item</li>
</ul><p>When the application is finished, it should look something like the following, except a bit prettier:</p>
<p style="text-align: center; height: 380px; margin: 24px 0px;">
<img src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/mockup/index.png" width="590" height="380"/>
</p><p>Additionally, our application should automatically save everything to disk, and it should allow the user to undo or redo <em>any</em> change.</p><h3>How Do We Organize It?</h3><p>When building applications using PLRelational, we use an approach that is very similar to MVVM (Model / View / View Model).</p><p>In traditional MVVM-based apps, it is often the case that the <em>Model</em> layer is based on some sort of in-memory object graph that is pulled from (and stored back to) some source, e.g. files on disk, a database, or the network.</p><p>With PLRelational, we forego the traditional object graph and instead build the <em>Model</em> by declaring how our source relations are laid out (most likely backed by some on-disk storage, e.g. plists or SQLite) and defining some base operations that modify those relations.</p>
<p style="text-align: center; height: 468px; margin-top: -20px; margin-bottom: 2px;">
<img src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/mvvm/index.png" width="624" height="468"/>
</p><p>As seen in this diagram, when building with PLRelational the implementation of each piece of the user interface is typically spread across three layers:</p>
<ul>
  <li><p>In the <strong><em>Model</em></strong> layer, we declare our source <code>Relation</code>s and define transactions that modify those <code>Relation</code>s.</p></li>
  <li><p>In the <strong><em>View Model</em></strong> layer, we declare <code>Relation</code> / <code>Signal</code> / <code>Property</code> chains that express how the data from our <em>Model</em> layer is to be transformed for display. If the interaction is two-way, as is the case for something like a text field, we'll also declare how changes made by the user should be transformed before being stored back via the <em>Model</em> layer.</p></li>
  <li><p>In the <strong><em>View</em></strong> layer, we define the views and bind them to the <code>Property</code> chains that we expressed in our <em>View Model</em> layer.</p></li>
</ul><p>Note that in a larger application, you would probably consider splitting up the <em>Model</em> layer over multiple classes for improved separation of concerns and modularity. Our to-do application on the other hand is relatively simple, so a single <code>Model</code> class will be sufficient to encapsulate all the relations we care about. </p><h3>Declaring Relations</h3><p>Let's begin building our <em>Model</em> layer by declaring the attributes and layout of our 4 relations, which will be stored on disk using property list files:</p>
<pre><code>/// Scheme for the `item` relation that holds the to-do items.
enum Item {
    static let id = Attribute(&quot;item_id&quot;)
    static let title = Attribute(&quot;title&quot;)
    static let created = Attribute(&quot;created&quot;)
    static let status = Attribute(&quot;status&quot;)
    static let notes = Attribute(&quot;notes&quot;)
    fileprivate static var spec: Spec { return .file(
        name: &quot;item&quot;,
        path: &quot;items.plist&quot;,
        scheme: [id, title, created, status, notes],
        primaryKeys: [id]
    )}
}

/// Scheme for the `tag` relation that holds the named tags.
enum Tag {
    static let id = Attribute(&quot;tag_id&quot;)
    static let name = Attribute(&quot;name&quot;)
    fileprivate static var spec: Spec { return .file(
        name: &quot;tag&quot;,
        path: &quot;tags.plist&quot;,
        scheme: [id, name],
        primaryKeys: [id]
    )}
}

/// Scheme for the `item_tag` relation that associates zero
/// or more tags with a to-do item.
enum ItemTag {
    static let itemID = Item.id
    static let tagID = Tag.id
    fileprivate static var spec: Spec { return .file(
        name: &quot;item_tag&quot;,
        path: &quot;item_tags.plist&quot;,
        scheme: [itemID, tagID],
        primaryKeys: [itemID, tagID]
    )}
}

/// Scheme for the `selected_item` relation that maintains
/// the selection state for the list of to-do items.
enum SelectedItem {
    static let id = Item.id
    fileprivate static var spec: Spec { return .transient(
        name: &quot;selected_item&quot;,
        scheme: [id],
        primaryKeys: [id]
    )}
}
</code></pre><p>We use enums to provide a namespace for the <code>Attribute</code>s associated with each <code>Relation</code>. For each one we also declare a <code>Spec</code> (typealias for <code>PlistDatabase.RelationSpec</code>) that tells our <code>PlistDatabase</code> how the relations will be stored on disk in property list format. In the case of <code>ItemTag</code> and <code>SelectedItem</code>, we use identifier attributes that act as foreign keys referring to the <code>Item</code> and <code>Tag</code> relations.</p><h3>Preparing the Model</h3><p>The next step is to use these "specs" to initialize a <code>PlistDatabase</code> by loading existing data from disk or creating a new one. We wrap it in a <code>TransactionalDatabase</code> so that we can capture and apply snapshots. That class also has a handy <code>saveOnTransactionEnd</code> feature that, when enabled, gives us auto-save functionality. Finally, we wrap the <code>TransactionalDatabase</code> in an <code>UndoableDatabase</code> which will help us coordinate undoable/redoable operations:</p>
<pre><code>class Model {
    let items: TransactionalRelation
    let tags: TransactionalRelation
    let itemTags: TransactionalRelation
    let selectedItemIDs: TransactionalRelation

    ...

    init(undoManager: PLRelationalBinding.UndoManager) {
        let specs: [Spec] = [
            Item.spec,
            Tag.spec,
            ItemTag.spec,
            SelectedItem.spec
        ]

        // Create a database or open an existing one (stored on disk using plists)
        let path = &quot;/tmp/TodoApp.db&quot;
        let plistDB = PlistDatabase.create(URL(fileURLWithPath: path), specs).ok!

        // Wrap it in a TransactionalDatabase so that we can use snapshots, and
        // enable auto-save so that all changes are persisted to disk as needed
        let db = TransactionalDatabase(plistDB)
        db.saveOnTransactionEnd = true
        self.db = db

        // Wrap that in an UndoableDatabase for easy undo/redo support
        self.undoableDB = UndoableDatabase(db: db, undoManager: undoManager)

        // Make references to our source relations
        func relation(for spec: Spec) -&gt; TransactionalRelation {
            return db[spec.name]
        }
        items = relation(for: Item.spec)
        tags = relation(for: Tag.spec)
        itemTags = relation(for: ItemTag.spec)
        selectedItemIDs = relation(for: SelectedItem.spec)
    }
}
</code></pre><h3>Wiring Up the User Interface</h3><p>Now that we've laid out our primary relations, let's set our sights on building out the user interface.</p><p>In this article we will be focusing on the left side of the application, namely the "Add a to-do" field and the list of to-do items. (There is a lot to share about the implementation of the right side too, but in the interests of time and space we will save that for Part 2, coming soon.)</p><p>Click the "Play" button below to see this part of the application in action:</p>
<p class="pt1-anim-gif-container" style="text-align: center; height: 520px;">
<img class="gifplayer" src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/todo-1-static/index.png" data-gif="/assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/todo-1.gif" width="662" height="510" data-label="Play"/>
</p><p>To keep things organized, I decided to break the application down into distinct functional requirements. Each requirement corresponds to a specific portion of the UI and explains how we want it to behave.</p><p>The following interactive screenshot shows the left half of the app in its completed state. Each red dot corresponds to a single functional requirement. Hover over a dot to read a summary of the requirement, then click to see how we implemented it using PLRelational.</p>
<div class="pt1-img-container">
    <img width="640" height="462" src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/screenshot-1/index.png" />
    <div id="pt1-blackout" class="blackout" hidden="true"></div>
    <a style="left: 2px; top: 43px;" class="pt1-req-link" id="req-link-1" href="#req1">1</a>
    <a style="left: 2px; top: 100px;" class="pt1-req-link" id="req-link-2" href="#req2">2</a>
    <a style="left: 44px; top: 182px;" class="pt1-req-link" id="req-link-3" href="#req3">3</a>
    <a style="left: 100px; top: 182px;" class="pt1-req-link" id="req-link-4" href="#req4">4</a>
    <a style="left: 284px; top: 182px;" class="pt1-req-link" id="req-link-5" href="#req5">5</a>
    <p id="pt1-req-popup" hidden="true"></p>
</div><p>In each of the sections that follow, we will show the relevant portions of code (really, a cross section of the <code>Model</code>, <code>*ViewModel</code>, and <code>*View</code> classes) that were used to implement a functional requirement. To explore the sources in Xcode, feel free to clone the <a href="https://github.com/plausiblelabs/plrelational">PLRelational</a> repository and follow along with the sources under <code>Example Apps</code> &gt; <code>TodoApp</code> in the project.</p>
<div class="req" id="req1-head">
<a class="pt1-req-target" name="req1"></a>
<h4 class="req-title">REQ-1: New Item Field</h4>
<p class="req-desc">
<i>A text field at top-left that allows the user to enter new to-do items.  When the user types a non-empty string, a new pending item should be added at the top of the list, and the text field should be cleared.</i>
</p>
</div><p>Let's translate this requirement into some code. The first step is to define an undoable transaction in the <code>Model</code> that adds a single row to the <code>items</code> relation. We expose this as an <code>ActionProperty</code> in the <code>ChecklistViewModel</code>, and then set up a binding in <code>ChecklistView</code>:</p>
<pre><code>class Model { ...
    /// Adds a new row to the `items` relation.
    private func addItem(_ title: String) {
        // Use UUIDs to uniquely identify rows.  Note that we can pass `id` directly
        // when initializing the row because `ItemID` conforms to the
        // `RelationValueConvertible` protocol.
        let id = ItemID()

        // Use a string representation of the current time to make our life easier
        let now = timestampString()

        // Here we cheat a little.  ArrayProperty currently only knows how to sort
        // on a single attribute (temporary limitation), we cram two things -- the
        // completed flag and the timestamp of the action -- into a single string of
        // the form &quot;&lt;0/1&gt; &lt;timestamp&gt;&quot;.  This allows us to keep to-do items sorted
        // in the list with pending items at top and completed ones at bottom.
        let status = statusString(pending: true, timestamp: now)

        // Insert a row into the `items` relation
        items.asyncAdd([
            Item.id: id,
            Item.title: title,
            Item.created: now,
            Item.status: status,
            Item.notes: &quot;&quot;
        ])
    }

    /// Adds a new row to the `items` relation.  This is an undoable action.
    func addNewItem(with title: String) {
        undoableDB.performUndoableAction(&quot;Add Item&quot;, {
            self.addItem(title)
        })
    }
}

class ChecklistViewModel { ...
    /// Creates a new to-do item with the given title.
    lazy var addNewItem: ActionProperty&lt;String&gt; = ActionProperty { title in
        self.model.addNewItem(with: title)
    }
}

class ChecklistView { ...
    init() { ...
        // Add a new item each time a string is entered into the text field
        newItemField.strings ~~&gt; model.addNewItem
    }
}
</code></pre><p>Note that the <code>EphemeralTextField</code> class in PLBindableControls takes care of delivering the text via its <code>strings</code> signal and clearing out the text field when the user presses enter.</p><p>Here we've established a pattern &mdash; breaking things down across the three components &mdash; that we'll see again and again in the implementation of our app. This layout encourages isolation between individual pieces of the UI and also allows for easy testing (a topic that we'll cover in a future article).</p>
<div class="req" id="req2-head">
<a class="pt1-req-target" name="req2"></a>
<h4 class="req-title">REQ-2: Items List</h4>
<p class="req-desc">
<i>A list view on the left side that contains all to-do items.  The list should be sorted such that the first part of the list contains pending items, and the second part contains completed items.  Pending items should be sorted with most recently added items at top.  Completed items should be sorted with most recently completed at top.</i>
</p>
</div><p>Table and outline views are a frequent source of headaches when building iOS and macOS applications. PLRelationalBinding and PLBindableControls include the <code>ArrayProperty</code> and <code>ListView</code> classes, respectively, that do a lot of heavy lifting so that we can focus simply on how the data is related. Here we use <code>arrayProperty</code> to lift the contents of our <code>items</code> relation into a form that can track rows by their unique identifier and keep them sorted by their <code>status</code> value:</p>
<pre><code>class ChecklistViewModel { ...
    /// The model for the list of to-do items.
    lazy var itemsListModel: ListViewModel&lt;RowArrayElement&gt; = {
        return ListViewModel(
            data: self.model.items.arrayProperty(idAttr: Item.id,
                                                 orderAttr: Item.status,
                                                 descending: true),
            cellIdentifier: { _ in &quot;Cell&quot; }
        )
    }()
}

class ChecklistView { ...
    init() { ...
        // Bind outline view to the list view model
        listView = CustomListView(model: model.itemsListModel,
                                  outlineView: outlineView)
    }
}
</code></pre><p>The <code>ListView</code> class reacts to changes in the <code>ArrayProperty</code>, taking care of animating insertions and deletions (as seen in the animation at the top of this section). As you can see, it takes very little code to set this up; no custom <code>NSTableViewDataSource</code> or <code>NSTableViewDelegate</code> implementation required.</p>
<div class="req" id="req3-head">
<a class="pt1-req-target" name="req3"></a>
<h4 class="req-title">REQ-3: Item Cell Completed Checkbox</h4>
<p class="req-desc">
<i>Each list cell will have a checkbox on the left side indicating whether the item is pending (unchecked) or completed (checked).  If the user clicks the checkbox such that it becomes checked, the item should animate down the list to sit at the top of the completed section.  If the user clicks the checkbox such that it becomes unchecked, the item should animate to the top of the list.</i>
</p>
</div><p>In the previous step, we used <code>ArrayProperty</code> to describe how the rows of to-do items are organized, but we still need to break each list cell down into three parts: checkbox, text field, and (tags) label.</p><p>For each of these cell components, we need to set up a conduit that takes data from a specific part of the underlying relation and delivers it to that part of the list cell.</p><p>Click the following to see an animation that helps visualize how, for each checkbox, we define a <code>Property</code> (in this case, an <code>AsyncReadWriteProperty&lt;CheckState&gt;</code>) that serves as a two-way transform:</p>
<p class="pt1-anim-gif-container" style="text-align: center; height: 299px; margin-bottom: 32px;">
<img class="gifplayer" src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/check-anim-static/index.png" data-gif="/assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/check-anim.gif" width="660" height="299" data-label="Play"/>
</p><p>Now, let's translate this into code. In <code>Model</code> we define a bidirectional transform that converts the checkbox state to our custom status string and vice versa. <code>ChecklistViewModel</code> creates an instance of that transform for a given <code>Row</code> (i.e., a list cell), and then in <code>ChecklistView</code> we bind the checkbox state to the view model:</p>
<pre><code>class Model { ...
    /// Returns a property that reflects the completed status for the given relation.
    func itemCompleted(_ relation: Relation, initialValue: String?) -&gt; AsyncReadWriteProperty&lt;CheckState&gt; {
        return relation.undoableTransformedString(
            undoableDB, &quot;Change Status&quot;, initialValue: initialValue,
            fromString: { CheckState(parseCompleted($0)) },
            toString: { statusString(pending: $0 != .on, timestamp: timestampString()) }
        )
    }
}

class ChecklistViewModel { ...
    /// Returns a read/write property that resolves to the completed status for
    /// the given to-do item.
    func itemCompleted(for row: Row) -&gt; AsyncReadWriteProperty&lt;CheckState&gt; {
        let itemID = ItemID(row[Item.id])
        let initialValue: String? = row[Item.status].get()
        let relation = self.model.items.select(Item.id *== itemID).project(Item.status)
        return self.model.itemCompleted(relation, initialValue: initialValue)
    }
}

class ChecklistView { ...
    init() { ...
        listView.configureCell = { view, row in ...
            // Bidirectionally bind checkbox state to the view model
            let checkbox = cellView.checkbox!
            checkbox.checkState.unbindAll()
            checkbox.checkState &lt;~&gt; model.itemCompleted(for: row)
        }
    }
}
</code></pre><p>There are a few things worth highlighting here:</p>
<ul>
  <li><p>In <code>Model</code>, our <code>itemCompleted</code> transform is set up using <code>undoableTransformedString</code> which provides built-in support for registering an action with the underlying <code>UndoManager</code>. <code>UndoableDatabase</code> will take care of reverting to the previous state if the user performs an "Undo" action, or reapplying the change after a "Redo" action.</p></li>
  <li><p>In <code>ChecklistViewModel</code>, note how we use <code>select</code> and <code>project</code> to hone in an individual value in a specific row of a relation. We are effectively setting up a live connection to that value, but note that we never have to explicitly load or store an object.</p></li>
  <li><p>In <code>ChecklistView</code>, the <code>&lt;~&gt;</code> operator means "set up a bidirectional binding between these two things": changes initiated by the user flow back to the model, and vice versa.</p></li>
</ul>
<div class="req" id="req4-head">
<a class="pt1-req-target" name="req4"></a>
<h4 class="req-title">REQ-4: Item Cell Title Field</h4>
<p class="req-desc">
<i>Each list cell will have the to-do item title to the right of the checkbox.  The user should be able to change the title by clicking in the list cell's text field.  The title field should be updated if the user changes it in the detail view, and vice versa.</i>
</p>
</div><p>The process we use to hook up the text field for each list cell is almost the same as what we did for the checkboxes in the previous step. Click to visualize:</p>
<p class="pt1-anim-gif-container" style="text-align: center; height: 299px; margin-bottom: 32px;">
<img class="gifplayer" src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/text-anim-static/index.png" data-gif="/assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/text-anim.gif" width="660" height="299" data-label="Play"/>
</p><p>Once again, let's translate this into code. The implementation of this requirement is very similar to the previous one, so it should all look familiar:</p>
<pre><code>class Model { ...
    /// Returns a property that reflects the item title.
    func itemTitle(_ relation: Relation, initialValue: String?) -&gt; AsyncReadWriteProperty&lt;String&gt; {
        return relation.undoableOneString(undoableDB, &quot;Change Title&quot;, initialValue: initialValue)
    }
}

class ChecklistViewModel { ...
    /// Returns a read/write property that resolves to the title for the given
    /// to-do item.
    func itemTitle(for row: Row) -&gt; AsyncReadWriteProperty&lt;String&gt; {
        let itemID = ItemID(row[Item.id])
        let initialValue: String? = row[Item.title].get()
        let relation = self.model.items.select(Item.id *== itemID).project(Item.title)
        return self.model.itemTitle(relation, initialValue: initialValue)
    }
}

class ChecklistView { ...
    init() { ...
        listView.configureCell = { view, row in ...
            // Bidirectionally bind title field to the view model
            let textField = cellView.textField as! TextField
            textField.string.unbindAll()
            textField.string &lt;~&gt; model.itemTitle(for: row)
        }
    }
}
</code></pre><p>The <code>itemTitle</code> transform is even simpler than the <code>itemCompleted</code> transform that we saw in the previous step. The <code>undoableOneString</code> convenience gives us a two-way (read/write) property that resolves to the title string value of the to-do item, and then writes updates back to the source relation when the user changes that string in the UI (again the undo support is handled for us).</p>
<div class="req" id="req5-head">
<a class="pt1-req-target" name="req5"></a>
<h4 class="req-title">REQ-5: Item Cell Tags Label</h4>
<p class="req-desc">
<i>Each list cell will have a read-only label containing applied tags on the right side.  The tags should be comma-separated and in alphabetical order.  The label should be updated whenever the user adds or removes a tag for that item in the detail view.</i>
</p>
</div><p>For the third and final piece of our list cells, we will display a string representation of the list of tags applied to that item. Unlike the previous two steps (checkbox and text field), this one doesn't accept input from the user, so it's just a matter of creating a read-only property. Click to visualize:</p>
<p class="pt1-anim-gif-container" style="text-align: center; height: 299px; margin-bottom: 32px;">
<img class="gifplayer" src="../../../../../assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/tags-anim-static/index.png" data-gif="/assets/images/blog/uploads/2017/09/18/build-with-plrelational-part-1/tags-anim.gif" width="660" height="299" data-label="Play"/>
</p><p>Here's what that looks like in code form:</p>
<pre><code>class Model { ...
    /// Returns a property that resolves to a string containing a comma-separated
    /// list of tags that have been applied to the given to-do item.
    func tagsString(for itemID: ItemID) -&gt; AsyncReadableProperty&lt;String&gt; {
        return self.itemTags
            .select(ItemTag.itemID *== itemID)
            .join(self.tags)
            .project(Tag.name)
            .allStrings()
            .map{ $0.sorted().joined(separator: &quot;, &quot;) }
            .property()
    }
}

class ChecklistViewModel { ...
    /// Returns a property that resolves to the list of tags for the given
    /// to-do item.
    func itemTags(for row: Row) -&gt; AsyncReadableProperty&lt;String&gt; {
        return self.model.tagsString(for: ItemID(row))
    }
}

class ChecklistView { ...
    init() { ...
        listView.configureCell = { view, row in ...
            // Bind detail (tags) label to the view model
            let detailLabel = cellView.detailLabel!
            detailLabel.string.unbindAll()
            detailLabel.string &lt;~ model.itemTags(for: row)
        }
    }
}
</code></pre><p>It's worth dissecting that <code>tagsString</code> declaration; it's an interesting one. Let's break it down step by step:</p>
<pre><code>// Start with the `itemTags` source relation (Item.id : Tag.id pairs)
self.itemTags

// Select the rows corresponding to the given to-do item
.select(ItemTag.itemID *== itemID)

// Join with the `tags` relation to get the tag names
.join(self.tags)

// Take just the tag names (we can drop the IDs)
.project(Tag.name)

// Derive a `Signal` that carries the tag names as a `Set&lt;String&gt;`
.allStrings()

// Convert the `Set&lt;String&gt;` into a sorted, comma-separated string
.map{ $0.sorted().joined(separator: &quot;, &quot;) }

// Lift the `Signal` into an `AsyncReadableProperty` that offers the latest value
.property()
</code></pre><p>This demonstrates a common practice when working with PLRelational:</p>
<ul>
  <li>Start with one or more <code>Relation</code>s</li>
  <li>Slice and dice (i.e., <code>select</code>, <code>join</code>, and <code>project</code>) until you've narrowed your focus onto a small set of data</li>
  <li>Derive a <code>Signal</code> that extracts Swift-ly typed values</li>
  <li>Transform the values using <code>Signal</code> operators like <code>map</code></li>
  <li>Lift to an <code>AsyncReadableProperty</code> for easier binding (and unit testing)</li>
</ul><p>By declaring the relationships in this manner, any time the list of tags changes for that to-do item (by virtue of the user adding/removing tags, or as a result of undo/redo, etc), the list cell will automatically be updated to display the latest string value.</p><h3>Wrapping Up</h3><p>In this article, we demonstrated how to use PLRelational and its reactive-relational style of programming to build a real, working macOS application.</p><p>Building the <em>PLRelational Way</em> takes a slightly different mindset as compared to more imperative, object-oriented approaches. However, once you've learned the few core patterns that we presented here, the reactive-relational approach becomes second nature, and using the vocabulary offered by PLRelational can help simplify the way you build applications.</p><p>In Part 2, we will continue our deep dive and explore the right half of the to-do application. In that article we will cover topics such as modeling list selection, building with complex controls like combo boxes, using cascading deletion, and more.</p><p>The complete source code for this application is available in the <a href="https://github.com/plausiblelabs/plrelational">PLRelational</a> repository under the <code>Examples/TodoApp</code> directory and can be run directly from the Xcode project.</p>
            </div>

            

<div class="sidebar">
    <h3>The Plausible Blog<a href="../../../../index-2.html?feed=rss2"><img src="../../../../../assets/images/blog/feed-icon/index.png" width="20px" height="20px" alt="" /></a></h3>
    <p>
        Latest news and musings from the co-op.
    </p>
    <p class="twitter">
        Follow us: <a href="https://twitter.com/plausiblelabs">&#64;plausiblelabs</a>
    </p>

    <h3>Recent Articles</h3>
    <ul>
        
            <li>
                <a href="../../../../2019/09/12/plcrashreporter-stewardship-moving-to-microsoft">PLCrashReporter Stewardship Moving to Microsoft</a>
                <span class="archive_date">September 12, 2019</span>
            </li>
        
            <li>
                <a href="../../../12/14/a-new-home-for-voodoopad">A New Home for VoodooPad</a>
                <span class="archive_date">December 14, 2017</span>
            </li>
        
            <li>
                <a href="../../../10/03/plrelational-query-optimization">PLRelational: Query Optimization and Execution</a>
                <span class="archive_date">October 3, 2017</span>
            </li>
        
            <li>
                <a href="../../28/build-with-plrelational-part-2">Let&#x27;s Build with PLRelational, Part 2</a>
                <span class="archive_date">September 28, 2017</span>
            </li>
        
            <li>
                <a href=".">Let&#x27;s Build with PLRelational, Part 1</a>
                <span class="archive_date">September 18, 2017</span>
            </li>
        
    </ul>
    <p class="archives">
        <a href="../../../../archive">Browse Archive</a>
    </p>

    <h3>More from Lab Members</h3>
    <ul class="blogRoll">
        <li>
            <a href="https://labonnesoupe.org/">Digital Things</a>
            <span class="blogRoll_author">from Chris Campbell</span>
        </li>
    </ul>
</div>
        </div>

        <br class="clearFloats" />

    </div>

            </div>
        <footer>
            <div class="inner">
                Plausible Labs Cooperative, Inc. &copy; 2008 - 2021
            </div>
        </footer>
    </body>

<!-- Mirrored from plausible.coop/blog/2017/09/18/build-with-plrelational-part-1 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Nov 2021 23:08:13 GMT -->
</html>
