







<!DOCTYPE html>

<html>
    
<!-- Mirrored from plausible.coop/blog/page/3 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Nov 2021 23:09:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <title>Blog</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans+Condensed:400|IBM+Plex+Sans:300,400,400i,500,700&amp;display=swap">
        <link rel="stylesheet" media="screen" href="../../../assets/stylesheets/main/index.css">
        
    <link rel="stylesheet" media="screen" href="../../../assets/stylesheets/blog/index.css">

        <link rel="shortcut icon" type="image/ico" href="../../../assets/images/main/favicon/index.ico">
        <script src="../../../assets/javascripts/jquery-1.9.0.min/index.js" type="text/javascript"></script>
        <script src="../../../assets/javascripts/retina/index.js" type="text/javascript"></script>
        
    <script type='text/javascript' src='../../../assets/javascripts/blog/jquery.gifplayer/index.js'></script>
    
    <script>
		$(document).ready( function(){
			$('.gifplayer').gifplayer();
		});
    </script>

    </head>
    <body>
        <header>
            <h3>
                <a href="../../../index/index.html">
                    <img src="../../../assets/images/main/clickable-logo-space/index.png" width="34px" height="34px" alt="PL" />
                </a>
            </h3>
            <ul>
                <li><a href="../../../software/index.html">Open Source</a></li>
                <li><a href="../../../portfolio/index.html">Portfolio</a></li>
                <li><a href="../../index.html">Blog</a></li>
                <li><a href="../../../about/index.html">About</a></li>
            </ul>
        </header>
            <div id="main">
                
    <div class="blog">

        <div class="main">

            <div class="articles">
                
                    <h1>
                        <a href="../../2017/09/07/plrelational-storage-formats/index.html">PLRelational: Storage Formats</a>
                    </h1>
                    <p class="author">September 7, 2017, by Mike Ash</p>
                    <p><em>This is our latest entry in a series of articles on <a href="https://github.com/plausiblelabs/plrelational">PLRelational</a>. For more background, check out these other articles in the series:</em></p>
<ul>
  <li><em><a href="../../2017/08/10/reactive-relational-programming-with-plrelational/index.html">Reactive Relational Programming with PLRelational</a></em></li>
  <li><em><a href="../../2017/08/24/intro-to-relational-algebra-using-plrelational/index.html">Introduction to Relational Algebra using PLRelational</a></em></li>
  <li><em><a href="../../2017/08/29/plrelational-observing-change/index.html">PLRelational: Observing Change</a></em></li>
</ul><p>We've been talking a lot lately about PLRelational and all the fancy stuff it does. However, we've been glossing over a fundamental part of it: how it actually stores data. After all, PLRelational is a data persistence framework at its core.</p><p>PLRelational's relations break down into two categories. There are relations which store rows, and there are relations which derive their contents by performing some operation on other relations. Many of the relations which store rows do so by persisting them to disk.</p><h3>Memory Relations</h3><p>Let's start with one that <em>doesn't</em> persist its contents, just for simplicity. The basic interface is the same, so it provides a good foundation.</p><p>The <code>MemoryTableRelation</code> class is a relation which, as the name indicates, stores its data in memory. You create one with a scheme:</p>
<pre><code>let people = MemoryTableRelation(scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;])
</code></pre><p>Once you have that, you can add, update, and delete rows:</p>
<pre><code>people.asyncAdd([&quot;id&quot;: 1, &quot;name&quot;: &quot;Lancelot&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncAdd([&quot;id&quot;: 2, &quot;name&quot;: &quot;Galahad&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncUpdate(Attribute(&quot;id&quot;) *== 2, newValues: [&quot;favorite-color&quot;: &quot;yellow&quot;])
people.asyncDelete(Attribute(&quot;id&quot;) *== 2)
</code></pre><p>Of course, this is purely in memory, and the data is lost once the <code>people</code> relation is destroyed. It can still be useful to represent transient data, but doesn't persist anything.</p><h3>Property List Files</h3><p>We might imagine taking this and building our own persistence on top of it by saving data to a property list file. We'd define a simple way to turn rows into property list objects. To save, we'd fetch the rows in the relation, convert them to property list objects, and save the whole thing into a file. To load, we'd load the property list file, convert it to rows, and add them to the relation.</p><p>This is essentially what <code>PlistFileRelation</code> is. It's an in-memory relation that's backed by a property list file. We can change <code>people</code> to use <code>PlistFileRelation</code> by changing the initialization:</p>
<pre><code>let people = try PlistFileRelation.withFile(plisturl,
    scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;],
    primaryKeys: [&quot;id&quot;], create: false
).orThrow()
</code></pre><p>It can then be used just like the in-memory version of <code>people</code>. It will automatically load data from the property list file, and when you want to save changes back to that file, call <code>save</code>:</p>
<pre><code>let result = people.save()
if let error = result.err {
    // handle error
}
</code></pre><p>You may have noticed the <code>primaryKeys</code> parameter in the code that creates the relation. Specifying primary keys allows PLRelational to optimize queries involving those attributes, at the expense of some overhead when adding, removing, or changing rows. <code>MemoryTableRelation</code> is assumed to always contain relatively small amounts of data and doesn't have this option.</p><h3>Property List Directories</h3><p>A single property list file works well for moderate amounts of data, but it requires reading the entire file at once, and rewriting the entire file on save. This overhead can become significant once you start working with large amounts of data.</p><p><code>PlistDirectoryRelation</code> solves this problem by storing the rows in individual files within a directory. This allows reading and writing individual rows separately.</p><p>We can use this by once again changing the initializer for <code>people</code>:</p>
<pre><code>let people = try PlistDirectoryRelation.withDirectory(dirurl,
    scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;],
    primaryKey: &quot;id&quot;, create: true
).orThrow()
</code></pre><p>As with <code>PlistFileRelation</code>, changes are not saved automatically. Instead, a delta is kept in memory, and then changes can be flushed to disk by calling <code>save</code>:</p>
<pre><code>let result = people.save()
if let error = result.err {
    // handle error
}
</code></pre><p>When creating a <code>PlistDirectoryRelation</code>, it takes a <code>primaryKey</code> parameter, singular. Unlike <code>PlistFileRelation</code>, <code>PlistDirectoryRelation</code> can only have a single primary key. This is due to how it efficiently locates the files for each row.</p><p>The filename for a row's plist is determined from the value for the primary key in that row. The filename is derived from that value by converting it to a canonical representation in raw bytes and then taking the SHA-256 hash of that representation. The result is something like:</p>
<pre><code>4cd9b7672d7fbee8fb51fb1e049f690342035f543a8efe734b7b5ffb0c154a45.rowplist
</code></pre><p>Because the mapping is deterministic and based only on the value of the primary key, equality queries for the primary key can be done quickly. In this example, the deletion at the end will compute the filename for the ID of <code>2</code> and then mark that file for deletion. Joins or selects involving the primary key will efficiently look up only the data they need.</p><h3>Property List Databases</h3><p>Your app will probably use multiple stored relations for different kinds of data. This may be a mix of property list files and directories. For example, you might place metadata that's needed everywhere in property list files, while large data that should only be loaded on demand is in a directory.</p><p>The <code>PlistDatabase</code> class handles this. You create it with a list of relation specs, which describe each relation's scheme, primary keys, path, and name. It then handles creating, loading, and saving all of those relations for you, and bundles them all into a single directory structure. This example creates a <code>people</code> relation stored in a file and a <code>people-images</code> relation stored in a directory, since images are probably large:</p>
<pre><code>let db = try PlistDatabase.create(rootURL, [
    .file(
        name: &quot;people&quot;, path: &quot;people.plist&quot;,
        scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;],
        primaryKeys: [&quot;id&quot;]
    ),
    .directory(
        name: &quot;people-images&quot;, path: &quot;people-images&quot;,
        scheme: [&quot;id&quot;, &quot;image-data&quot;],
        primaryKey: &quot;id&quot;
    )
]).orThrow()

let people = db[&quot;people&quot;]!
let images = db[&quot;people-images&quot;]!
</code></pre><p><code>people</code> and <code>images</code> will contain whatever data currently exists there, and can be manipulated with the standard <code>Relation</code> methods:</p>
<pre><code>people.asyncAdd([&quot;id&quot;: 1, &quot;name&quot;: &quot;Lancelot&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncAdd([&quot;id&quot;: 2, &quot;name&quot;: &quot;Galahad&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncUpdate(Attribute(&quot;id&quot;) *== 2, newValues: [&quot;favorite-color&quot;: &quot;yellow&quot;])
people.asyncDelete(Attribute(&quot;id&quot;) *== 2)

images.asyncAdd([&quot;id&quot;: 1, &quot;image-data&quot;: imageData])
</code></pre><p>To save changes back to disk, call <code>saveRelations</code>:</p>
<pre><code>let result = db.saveRelations()
if let error = result.err {
    // handle error
}
</code></pre><p>This will save all of the individual relations.</p><h3>Dropbox/Cloud Sync</h3><p>Property list storage works well for syncing to Dropbox and other cloud storage, which tend to work with file granularity. Placing a file relation in cloud storage allows the whole relation to be synced as a single unit, and using a directory relation allows individual rows to be added, updated, and deleted independently.</p><p>PLRelational doesn't directly talk to cloud storage, but it does have some special facilities to accommodate it. Ultimately there are two kinds of actions that need to be handled: local changes to files which need to be synced to the server, and remote changes to files which need to be synced locally.</p><p>Local changes are handled using <code>PlistDatabase</code>'s <code>addSaveObserver</code> method. Pass it a function which will be invoked any time any of the relations in the database change a file on disk. It receives the <code>URL</code> of the file that was changed. It can then take whatever action is needed, like making an API call, to sync that file:</p>
<pre><code>db.addSaveObserver({ url in
    cloudAPI.syncLocalFile(url)
})
</code></pre><p>Local changes are handled by asking the <code>PlistDatabase</code> to make a change to a local <code>URL</code>. To replace a local file with a new version, call <code>replaceLocalFile</code>. This can also be used to add a new file, by giving it the <code>URL</code> to where the new file should go:</p>
<pre><code>func gotNewFile(tmpURL: URL, localFileURL: URL) {
    db.replaceLocalFile(url: localFileURL, movingURL: tmpURL)
}

func gotNewFileVersion(tmpURL: URL, localFileURL: URL) {
    db.replaceLocalFile(url: localFileURL, movingURL: tmpURL)
}
</code></pre><p>Note that the new file must first be saved to a temporary location, and the <code>PlistDatabase</code> takes care of moving it to its final location. This allows <code>PlistDatabase</code> to read any old data that was in the file previously, which is necessary to generate proper change notifications.</p><p>To delete a local file, call <code>deleteLocalFile</code>:</p>
<pre><code>func deleteFile(url: URL) {
    db.deleteLocalFile(url: url)
}
</code></pre><p>These methods understand the layout of the database's files on disk and will look up the appropriate <code>Relation</code> for any given local URL. When applying the changes, the <code>Relation</code> in question will generate the appropriate change notifications, meaning that your UI remains automatically in sync with any changes generated by cloud sync activity. It's also smart enough to know which files are <em>not</em> part of the database, and will refuse to perform the operation if asked to operate on a URL that doesn't belong to the database. The return value of these methods will tell you whether the action was performed or not, making it easy to sync files outside the <code>PlistDatabase</code> too.</p><h3>SQLite Databases</h3><p>SQLite and PLRelational fit together well. SQLite was our first target for persistent storage, and PLRelational's data types match what SQLite provides.</p><p>PLRelational's SQLite support starts with the <code>SQLiteDatabase</code> class. As the name indicates, this represents an SQLite database, and it provides the individual tables in the database as <code>Relation</code> objects.</p><p>To create an <code>SQLiteDatabase</code> instance, initialize it with a path to the database file:</p>
<pre><code>let db = try SQLiteDatabase(path)
</code></pre><p>If a database already exists at that location, it will open the existing database. Otherwise it will create a new one.</p><p>To create a new table, use the <code>createRelation</code> method:</p>
<pre><code>let people = try db.createRelation(
    &quot;people&quot;,
    scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;]).orThrow()
</code></pre><p>To fetch an existing table, use subscripting with the table name:</p>
<pre><code>let images = db[&quot;people-images&quot;]
</code></pre><p>For the common case where you want to create the table if it doesn't exist and fetch it if it does, use the <code>getOrCreateRelation</code> method:</p>
<pre><code>let people = try db.getOrCreateRelation(
    &quot;people&quot;,
    scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;]).orThrow()
let images = try db.getOrCreateRelation(
    &quot;people-images&quot;,
    scheme: [&quot;id&quot;, &quot;image-data&quot;]).orThrow()
</code></pre><p>As before, once you have the <code>Relation</code>s, you can manipulate them with the usual calls:</p>
<pre><code>people.asyncAdd([&quot;id&quot;: 1, &quot;name&quot;: &quot;Lancelot&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncAdd([&quot;id&quot;: 2, &quot;name&quot;: &quot;Galahad&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncUpdate(Attribute(&quot;id&quot;) *== 2, newValues: [&quot;favorite-color&quot;: &quot;yellow&quot;])
people.asyncDelete(Attribute(&quot;id&quot;) *== 2)

images.asyncAdd([&quot;id&quot;: 1, &quot;image-data&quot;: Data(imageData)])
</code></pre><p>Unlike property list storage, the SQLite storage saves changes immediately. The <code>asyncAdd</code> call translates directly to an SQLite <code>INSERT</code> statement, for example. If you want to buffer changes in memory and only flush them to disk with an explicit save, you can accomplish this by wrapping the <code>SQLiteDatabase</code> in a <code>ChangeLoggingDatabase</code>:</p>
<pre><code>let sqliteDB = try SQLiteDatabase(path)
_ = try sqliteDB.getOrCreateRelation(
    &quot;people&quot;,
    scheme: [&quot;id&quot;, &quot;name&quot;, &quot;quest&quot;, &quot;favorite-color&quot;]).orThrow()
_ = try sqliteDB.getOrCreateRelation(
    &quot;people-images&quot;,
    scheme: [&quot;id&quot;, &quot;image-data&quot;]).orThrow()

let db = ChangeLoggingDatabase(sqliteDB)
let people = db[&quot;people&quot;]
let images = db[&quot;people-images&quot;]

people.asyncAdd([&quot;id&quot;: 1, &quot;name&quot;: &quot;Lancelot&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncAdd([&quot;id&quot;: 2, &quot;name&quot;: &quot;Galahad&quot;,
                 &quot;quest&quot;: &quot;to find the holy grail&quot;, &quot;favorite-color&quot;: &quot;blue&quot;])
people.asyncUpdate(Attribute(&quot;id&quot;) *== 2, newValues: [&quot;favorite-color&quot;: &quot;yellow&quot;])
people.asyncDelete(Attribute(&quot;id&quot;) *== 2)

images.asyncAdd([&quot;id&quot;: 1, &quot;image-data&quot;: Data(imageData)])
</code></pre><p><code>ChangeLoggingDatabase</code> will record all changes made to its relations rather than passing them directly to the SQLite layer. When you want to persist all changes, call <code>save</code>:</p>
<pre><code>let result = db.save()
if let error = result.err {
    // handle error
}
</code></pre><p>This passes all of the changes to the SQLite layer, which writes them out all at once.</p><h3>Advanced: Raw SQL in SQLite</h3><p>For advanced uses, it's also possible to execute SQL queries directly against the database using the <code>executeQuery</code> method. This takes an SQL string and an optional array of <code>RelationValue</code> parameters and returns <code>Row</code>s for the results. PLRelational uses this to implement <code>RelationTextIndex</code>, which is a full text search API backed by SQLite's <code>fts4</code> module.</p><p>If you use this, it's important to note that there is not a perfect mapping between <code>RelationValue</code> types and SQLite data types. The standard SQL <code>NULL</code> <a href="https://sqlite.org/nulls.html">has a lot of weird behaviors</a>. For example, comparing <code>NULL</code> for equality or inequality always produces <code>NULL</code>, which is evaluated as false. That means that, for example, a <code>SELECT</code> statement checking for <code>== NULL</code> or <code>!= NULL</code> will always produce zero results regardless of the contents of the table.</p><p>SQLite matches this weird behavior in order to be compatible with other SQL databases. PLRelational doesn't have that constraint and so we decided to make <code>NULL</code> behave more consistently, and act like any other value. PLRelational's <code>RelationValue.null</code> is equal to itself, not equal to other values, gets sorted consistently, etc. However, this means that we can't use SQLite's <code>NULL</code> while still translating PLRelational <code>select</code> operations into SQLite <code>SELECT</code> statements. To work around this, we decided not to use SQLite's <code>NULL</code> at all, and instead translate <code>RelationValue.null</code> differently.</p><p>Instead, <code>RelationValue.null</code> is translated into an SQLITE blob containing the ASCII bytes <code>&quot;NULL&quot;</code>. In order to ensure that actual blobs are never mistakenly interpreted as <code>null</code>, all blobs are prefixed with the ASCII bytes <code>&quot;BLOB&quot;</code>. This works fine for normal PLRelational use and this translation step is invisible unless you go digging through the database by hand. However, if you're submitting raw SQL with <code>executeQuery</code>, it might get in the way. The optional <code>bindBlobsRaw</code> parameter allows you to control whether blobs are translated like this while going into and out of SQLite. It's <code>false</code> by default, meaning that translation is performed. By setting it to <code>true</code>, blobs will be passed in and out as-is. Note that this parameter does not influence how <code>NULL</code> is translated.</p><h3>Try It Out</h3><p>If you'd like to try out these code snippets or otherwise explore the available options, grab a copy of the official <a href="https://github.com/plausiblelabs/plrelational">PLRelational repository</a>. The project includes example apps which you can examine and modify, and adding PLRelational to your own project is as easy as dropping the framework in and writing <code>import PLRelational</code> in your code.</p><p><br/> <em><strong>Need help?</strong> Plausible Labs offers consulting services for software engineering. If you'd like some professional assistance, whether with PLRelational or for something entirely different, consider us. More information can be found on our <a href="../../../portfolio/index.html">consulting</a> page.</em></p>
                
                    <h1>
                        <a href="../../2017/08/29/plrelational-observing-change/index.html">PLRelational: Observing Change</a>
                    </h1>
                    <p class="author">August 29, 2017, by Chris Campbell</p>
                    <p><em>This is the second in a series of articles exploring the PLRelational framework. For a more general overview of PLRelational and friends, check out <a href="../../2017/08/10/reactive-relational-programming-with-plrelational/index.html">Reactive Relational Programming with PLRelational</a>. To learn more about relational algebra and how it is used in PLRelational, head over to the <a href="../../2017/08/24/intro-to-relational-algebra-using-plrelational/index.html">first article</a> in this series.</em></p><p>Before looking into all the goodies that PLRelational and PLRelationalBinding have to offer, it helps to first understand how the core <code>Relation</code> classes compute and deliver changes.</p><p>As a brief recap, PLRelational provides <a href="../../2017/08/24/intro-to-relational-algebra-using-plrelational/index.html">combinators</a> that allow you to express a <code>Relation</code> through composition of other relations, and then register an observer that is notified whenever something changes. When a change is made to a lower-level <code>Relation</code>, each subsequent <code>Relation</code> interprets the changes reported by the one that came before it in the chain, producing a new set of changes, and so on.</p><p>To help illustrate this, we will set up a couple very simple "source" <code>Relations</code> and then use them to build up more interesting <code>Relations</code> through composition.</p><h4>Step 0: Declaring Relations</h4><p>First we will declare some <code>Attribute</code>s for our two <code>Relation</code>s using enums for quick-and-easy namespacing. It is possible to use a string literal in place of an <code>Attribute</code> but to avoid typos it's best to just declare an <code>Attribute</code> for each.</p>
<pre><code>enum Fruit {
    static let id = Attribute(&quot;id&quot;)
    static let name = Attribute(&quot;name&quot;)
}

enum SelectedFruit {
    static let _id = Attribute(&quot;_id&quot;)
    static let fruitID = Attribute(&quot;fruit_id&quot;)
}
</code></pre><p>Now that we have our <code>Attribute</code>s we can initialize our source <code>Relation</code>s: </p>
<pre><code>// Prepare the source relations
let memoryDB = MemoryTableDatabase()
let db = TransactionalDatabase(memoryDB)
func createRelation(_ name: String, _ scheme: Scheme) -&gt; TransactionalRelation {
    _ = memoryDB.createRelation(name, scheme: scheme)
    return db[name]
}

// Each item in the `fruits` relation will have a unique identifier and a
// (possibly misspelled) name
fruits = createRelation(
    &quot;fruit&quot;,
    [Fruit.id, Fruit.name])

// The `fruit_id` attribute in the `selectedFruitsIDs` relation acts as a
// foreign key, referring to a row from the `fruits` relation
selectedFruitIDs = createRelation(
    &quot;selected_fruit_id&quot;,
    [SelectedFruit._id, SelectedFruit.fruitID])
</code></pre><p>We will also use the aforementioned combinators to create two higher-level <code>Relation</code>s that will be used in our examples below:</p>
<pre><code>// Join `fruits` with `selectedFruitIDs` to produce a new Relation that will
// contain our fruit(s) of interest.  (In a real application we might use this
// setup to model the selection state for a list view, for example.)
selectedFruits = fruits.equijoin(selectedFruitIDs,
                                 matching: [Fruit.id: SelectedFruit.fruitID])

// Project just the `name` Attribute to produce another Relation that will
// contain only a single string value (the selected fruit&#39;s name)
selectedFruitName = selectedFruits.project(Fruit.name)
</code></pre><p>Now that we've created some <code>Relation</code>s we will demonstrate how data can be added and modified. For each of the following examples, we have a code block showing the changes that were initiated, followed by an animation showing how those changes flow through the relations. On the right side of each animation you can see the raw set of changes delivered to observers of each relation. (These animations were produced using the <a href="https://github.com/plausiblelabs/plrelational/tree/master/Examples/RelationChangeApp">RelationChangeApp</a> demo from the PLRelational repository; check out the source code of that example application if you'd like to see how things work in more detail.)</p><h4>Step 1: Initial Data</h4><p>Let's start by inserting a few <code>Row</code>s into our source relations:</p>
<pre><code>// Step 1: Populate the empty relations
fruits.asyncAdd([Fruit.id: 1, Fruit.name: &quot;Apple&quot;])
fruits.asyncAdd([Fruit.id: 2, Fruit.name: &quot;Apricot&quot;])
fruits.asyncAdd([Fruit.id: 3, Fruit.name: &quot;Bandana&quot;])
selectedFruitIDs.asyncAdd([SelectedFruit._id: 0, SelectedFruit.fruitID: 1])
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-1-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-1.gif" width="646" height="441" data-label="Play"/>
</p>
<p style="text-align: center; font-size: 0.8em;"><i>Click "Play" to watch the changes flow through the relations.</i></p><p>Note that multiple changes made to relations on the same runloop iteration are coalesced into a single logical transaction. The query planner and optimizer ensure that the changes are processed together, and observers will see a single batch of updates delivered.</p><p>There are a few different kinds of observers in PLRelational, but for the purposes of this article we will focus on just one: <code>AsyncRelationChangeCoalescedObserver</code>. When an observer of this type is registered with a <code>Relation</code> (by calling <code>addAsyncObserver</code>), the observer will receive a <code>RowChange</code> object that tells you the <code>Row</code>s that were added and removed as a result of all changes that were processed. In the example app that produced these animations, our observers simply pretty-print the <code>RowChange</code> contents, which is what gets displayed in the black box; for Step 1 this looks like the following:</p>
<pre><code>============================
fruits
----------------------------
Added
[id: 1, name: Apple]
[id: 2, name: Apricot]
[id: 3, name: Bandana]
============================

============================
selectedFruitIDs
----------------------------
Added
[_id: 0, fruit_id: 1]
============================

============================
selectedFruits
----------------------------
Added
[id: 1, name: Apple]
============================
</code></pre><p>This first example was straightforward: three rows were added to the <code>fruits</code> relation, and one row was added to the <code>selectedFruitIDs</code> relation. In the app we also added an observer on the <code>selectedFruits</code> relation, which you recall was a <code>join</code> of the two source relations. Here we can see that a single row (for "Apple") was added as a result of the initial join, since Apple's <code>id</code> matches the <code>fruit_id</code> of the single row in <code>selectedFruitIDs</code>.</p><h4>Step 2: Deletion</h4><p>Next, we will delete a single row from the <code>fruits</code> relation:</p>
<pre><code>// Step 2: Delete &quot;Apricot&quot;
fruits.asyncDelete(Fruit.id *== 2)
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-2-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-2.gif" width="646" height="441" data-label="Play"/>
</p><p>This change affected only the <code>fruits</code> relation, and its observer sees that a single row was removed. (Note that the observers for the other two relations <em>may</em> also be notified that a change happened <em>somewhere</em>, but the <code>RowChange</code> will be empty to indicate that this particular relation was unaffected. This is something of a quirk caused by a combination of the current observer API and the optimizer's implementation; both are works in progress and this behavior will likely improve with time.)</p><h4>Step 3: Insertion</h4><p>For the next step, we will add a single (misspelled) row to the <code>fruits</code> relation:</p>
<pre><code>// Step 3: Insert &quot;Cheri&quot;
fruits.asyncAdd([Fruit.id: 4, Fruit.name: &quot;Cheri&quot;])
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-3-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-3.gif" width="646" height="441" data-label="Play"/>
</p><p>As with the previous step, this change only affected the <code>fruits</code> relation. The other two relations were unaffected.</p><h4>Step 4: Simple Update</h4><p>That covers the simple insertion and deletion cases. What if we instead want to update a particular value in one or more existing rows? For this we can turn to <code>asyncUpdate</code>, which takes a <code>SelectExpression</code> (to narrow the focus of the update) along with the set of values that will replace the existing ones:</p>
<pre><code>// Step 4: Fix spelling of &quot;Cherry&quot; by updating the source relation
fruits.asyncUpdate(Fruit.id *== 4, newValues: [Fruit.name: &quot;Cherry&quot;])
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-4-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-4.gif" width="646" height="441" data-label="Play"/>
</p><p>When a <code>Relation</code> is updated, the <code>RowChange</code> does not include a third set of <code>Row</code>s similar to <code>added</code> and <code>removed</code>; instead, observers will see this as a "remove" (with the previous row content) along with an "add" (with the updated row content). This approach simplifies PLRelational internals while still allowing higher level code to identify an update as opposed to a pure insert or delete. In fact, the PLRelationalBinding framework includes a class called <code>RelationChangeParts</code> to help break down a relation change into those nice buckets.</p><p>Note that there are other ways to simplify and narrow the focus of an update (instead of explicitly updating a row by its unique identifier); we will see one such approach later in Step 6.</p><p><em>Brief aside: Why do many of these functions and classes include the word "async" you may wonder? Isn't PLRelational geared towards asynchronous processing by default? The answer is that in our earliest prototypes we only had support for synchronous mutation and fetching. Later we implemented the various asynchronous APIs (along with query optimization, etc) that worked alongside the original synchronous APIs, and that new naming stuck. At this time we encourage use of only the asynchronous APIs; we will most likely remove the synchronous ones, at which point we could drop "async" from those names.</em></p><h4>Step 5: Forward-propagating Update</h4><p>Now, suppose we want to make "Bandana" the selected fruit. This is as simple as performing an <code>asyncUpdate</code> on the single row in the <code>selectedFruitIDs</code> relation:</p>
<pre><code>// Step 5: Mark &quot;Bandana&quot; as the selected fruit
selectedFruitIDs.asyncUpdate(true, newValues: [SelectedFruit.id: 3])
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-5-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-5.gif" width="646" height="441" data-label="Play"/>
</p><p>In this case, the <code>fruits</code> relation was unaffected, but the change in <code>selectedFruitIDs</code> has propagated to the join (<code>selectedFruits</code>) relation. Each relation will produce an add and a remove, indicating that the row is being updated.</p><h4>Step 6: Reverse-propagating Update</h4><p>Finally, let's fix the spelling of the selected fruit ("Banana"), but this time we will use a different technique. In Step 4 we updated the "Cheri" row by performing an <code>asyncUpdate</code> directly on the <code>fruits</code> relation. This time we will apply the update to our <code>selectedFruitName</code> relation. We use the <code>asyncUpdateString</code> convenience, which assumes a single-attribute relation (like <code>selectedFruitName</code>, which projects a single <code>name</code> attribute) and updates all rows (only one row in this case) with the new value:</p>
<pre><code>// Step 6: Fix spelling of the selected fruit (&quot;Banana&quot;) by applying
// the update to the higher-level relation (will automatically propagate
// back to the source relation)
selectedFruitName.asyncUpdateString(&quot;Banana&quot;)
</code></pre>
<p style="text-align: center; height: 445px;">
<img class="gifplayer" src="../../../assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-6-static/index.png" data-gif="/assets/images/blog/uploads/2017/08/29/plrelational-observing-change/rc-step-6.gif" width="646" height="441" data-label="Play"/>
</p><p>This demonstrates a cool feature of PLRelational, where updates can be applied to a higher-level <code>Relation</code> (i.e., one formed by composition with the help of the core combinators); those changes will propagate through the tree and will ultimately be applied to the underlying source relation. In this case, we applied the update to our <code>selectedFruitName</code> relation, and PLRelational was smart enough to apply those changes back to the corresponding row in the underlying <code>fruits</code> relation.</p><p>This feature is especially handy when working at the UI level. For example, we can have a form-style user interface with a <code>TextField</code> that is bound to the selected employee's first name. The user can edit the <code>TextField</code> and those changes will be written back to the original employee table in an on-disk database. We didn't have to write code that keeps the selected employee ID in memory, or explicitly write to the employee table using that ID.</p><h4>Go Forth and Explore</h4><p>As mentioned above, the examples from this article are taken from the <a href="https://github.com/plausiblelabs/plrelational/tree/master/Examples/RelationChangeApp">RelationChangeApp</a> demo in the PLRelational repository. Using that macOS application, you can step through each example and follow the animated visualizations to see how changes flow through the system. The <code>ViewModel</code> class is where the example steps are defined. Feel free to modify the code and add your own steps to get a better feel for how things work!</p><h4>Next Steps</h4><p>In this article we showed different ways to change the contents of a <code>Relation</code> and what those changes look like to an observer. These are fundamental concepts in PLRelational, and it is important to understand these basics before we move on to explore the features they enable, especially those in the PLRelationalBinding layer. So far we've just scratched the surface in discussing what PLRelational has to offer. In upcoming articles we plan to deep-dive into <em>how</em> things work (efficiently) in the implementation of PLRelational and also explore <em>what</em> becomes possible when you structure your application with a reactive-relational mindset.</p><p><br/> <em><strong>Need help?</strong> Plausible Labs offers consulting services for software engineering. If you'd like some professional assistance, whether with PLRelational or for something entirely different, consider us. More information can be found on our <a href="../../../portfolio/index.html">consulting</a> page.</em></p>
                
                    <h1>
                        <a href="../../2017/08/24/intro-to-relational-algebra-using-plrelational/index.html">An Introduction to Relational Algebra Using PLRelational</a>
                    </h1>
                    <p class="author">August 24, 2017, by Mike Ash</p>
                    <p>We recently <a href="../../2017/08/10/reactive-relational-programming-with-plrelational/index.html">announced PLRelational</a>, our framework for storing and working with data that is based on relational algebra. This raises the question: what exactly is relational algebra? Most of the material out there is either highly academic, or focused on SQL databases. This article will give an overview of the basics of relational algebra in a way that programmers can easily understand, aimed at explaining the foundations that PLRelational is built on. Terminology will match what PLRelational uses.</p><p>Relational algebra looks a lot like set theory, with some extra constraints and specialized operations. If "set theory" scares you, not to worry: for our purposes, just think of Swift's <code>Set</code> type. We'll be dealing with the same things here: an unordered collection of unique items which you can iterate over, ask about membership, and combine in various ways. PLRelational even uses <code>Set</code> to represent certain relations.</p><h3>Terminology</h3><p>Let's build up terminology from the simplest elements. The most basic component is a value, which PLRelational represents using the <code>RelationValue</code> type. Values represent your data, such as a username, a timestamp, or a boolean flag. Conceptually a value can be anything that can be checked for equality, but practically we need some limits on what they can be. PLRelational mimics SQLite's value types, and allows values to be 64-bit integers, double-precision floating-point numbers, strings, blobs (raw data expressed as a byte array), and null.</p><p>Another basic component is an attribute, which PLRelational represents with the <code>Attribute</code> type. This acts like a dictionary key and is essentially a string. Each value is stored under an attribute.</p><p>Values and attributes are combined into rows. Rows are essentially dictionaries, with attributes as the keys and values as the values. In fact, PLRelational's <code>Row</code> type originally stored its contents as <code>[Attribute: RelationValue]</code>. The current implementation is more sophisticated, but the functionality is the same.</p><p>A relation, represented with the <code>Relation</code> type, is conceptually a set of rows. All rows within a given relation have the same set of attributes, which is called a scheme.</p><p>To summarize:</p>
<ul>
  <li>Relation: a set of unique rows, all of which have the same scheme.</li>
  <li>Row: a bunch of values, each associated with a unique attribute.</li>
  <li>Scheme: the set of attributes in a row.</li>
  <li>Attribute: a string describing the meaning or purpose of a value.</li>
  <li>Value: a primitive chunk of data, holding a string, integer, or similar.</li>
</ul><h3>Example</h3><p>Let's quickly look at a concrete example. We'll track a list of employees, where each employee has a name and an ID. We can set this up in PLRelational with a little bit of code:</p>
<pre><code>let employees = MemoryTableRelation(scheme: [&quot;name&quot;, &quot;id&quot;])
employees.asyncAdd([&quot;name&quot;: &quot;Jane Doe&quot;, &quot;id&quot;: 1])
employees.asyncAdd([&quot;name&quot;: &quot;John Smith&quot;, &quot;id&quot;: 2])
</code></pre><p>This example uses <code>MemoryTableRelation</code>, which as the name indicates stores the data directly in memory. This same code could easily use a different backing store, such as an SQLite database or a property list file, just by changing <code>MemoryTableRelation</code> to the appropriate type. We can also use the <code>MakeRelation</code> function as a convenient shorthand for creating a <code>MemoryTableRelation</code> without having to type attribute names over and over:</p>
<pre><code>let employees = MakeRelation(
    [&quot;name&quot;,       &quot;id&quot;],
    [&quot;Jane Doe&quot;,   1],
    [&quot;John Smith&quot;, 2])
</code></pre><p>When pretty-printed, it looks like this:</p>
<pre><code>id  name      
1   Jane Doe  
2   John Smith
</code></pre><p>The <code>employees</code> variable holds a relation. Its scheme consists of the attributes <code>&quot;name&quot;</code> and <code>&quot;id&quot;</code>. It holds two rows, both of which have those attributes. The row values hold the employees' names and IDs.</p><h3>Basic Set Operations</h3><p>Relations are sets of rows. What sorts of operations can you do on them? To start with, you can do the same things you can do to sets.</p><p>To start with something really simple, you can union two relations. The result contains everything that was in either original relation. In PLRelational, you can create a new relation that represents this operation by using the <code>union</code> method:</p>
<pre><code>let allEmployees = oldEmployees.union(newEmployees)
</code></pre><p>This can also be done using the <code>+</code> operator:</p>
<pre><code>let allEmployees = oldEmployees + newEmployees
</code></pre><p>If <code>oldEmployees</code> contains this:</p>
<pre><code>id  name      
2   John Smith
1   Jane Doe  
</code></pre><p>And <code>newEmployees</code> contains this:</p>
<pre><code>id  name         
3   Tim S        
4   Susan Johnson
</code></pre><p>Then <code>allEmployees</code> contains all entries from both:</p>
<pre><code>id  name         
2   John Smith   
1   Jane Doe     
3   Tim S        
4   Susan Johnson
</code></pre><p>When it comes to PLRelational, it's important to note that creating <code>allEmployees</code> like this does not actually perform any work on the data! It just creates a new relation object which represents the union of the others. The actual work of gathering the data and unioning it together only happens when you ask <code>allEmployees</code> (or some other relation derived from it) for its contents. This is true for all relation operators: you build up new relation objects representing the operations applied to the given operands, and work only happens when you request data.</p><p>The difference operation works in much the same way. It produces only the rows contained in the first operand, but not rows also contained in the second. Similar to <code>union</code>, you can use the <code>difference</code> method to make a new relation representing the operation:</p>
<pre><code>let managementEmployees = allEmployees.difference(frontlineEmployees)
</code></pre><p>As with union, you can also use an operator:</p>
<pre><code>let managementEmployees = allEmployees - frontlineEmployees
</code></pre><p>As an example, if these are the <code>frontlineEmployees</code>:</p>
<pre><code>id  name         
2   John Smith   
4   Susan Johnson
</code></pre><p>And <code>allEmployees</code> is as shown above, then <code>managementEmployees</code> contains this:</p>
<pre><code>id  name    
1   Jane Doe
3   Tim S   
</code></pre><p>There's also an intersection operation, which produces only the rows contained in both operands. The <code>intersection</code> method produces a relation representing an intersection:</p>
<pre><code>let nightManagers = nightEmployees.intersection(managementEmployees)
</code></pre><p>And there's also an operator, although this one is difficult to type:</p>
<pre><code>let nightManagers = nightEmployees ∩ managementEmployees
</code></pre><p>For an example here, if <code>nightEmployees</code> contains this:</p>
<pre><code>id  name         
1   Jane Doe     
4   Susan Johnson
</code></pre><p>Then <code>nightManagers</code> contains this:</p>
<pre><code>id  name    
1   Jane Doe
</code></pre><h3>Select</h3><p>A select is a filter operation on a relation. It takes a relation and a predicate and produces a relation containing only the rows where the predicate is true.</p><p>In PLRelational, predicates are values which conform to the <code>SelectExpression</code> protocol. A <code>SelectExpression</code> is something that can take a row and produce a <code>RelationValue</code>. If the result of a <code>SelectExpression</code> is an integer zero, it's considered to be false. All other values are considered to be true.</p><p>PLRelational provides a bunch of built-in <code>SelectExpression</code> types. Simple values like <code>String</code> and <code>Int64</code> conform, and they're implemented to ignore the passed-in row and produce their value as a <code>RelationValue</code>. <code>Attribute</code> also conforms, and it produces the row's value for that attribute.</p><p>It also provides a bunch of operators such as equality, comparison, and logical AND/OR. Because these operators build expressions rather than producing results immediately, they are prefixed with a <code>*</code> to distinguish them from the standard operators like <code>==</code> or <code>&lt;</code>.</p><p>To filter a relation in PLRelational, call the <code>select</code> method with a select expression:</p>
<pre><code>let employeeFour = employees.select(Attribute(&quot;id&quot;) *== 4)
let earlyEmployees = employees.select(Attribute(&quot;id&quot;) *&lt;= 10)
</code></pre><p>As before, this creates a relation which will perform the given operation on demand, but doesn't do any filtering work until then.</p><h3>Project and Rename</h3><p>Sometimes it's useful to manipulate the attributes in a relation without manipulating the underlying data.</p><p>Rename is a really simple operation: it takes a list of attribute pairs, and produces a new relation where the first attribute in each pair is renamed to the second one. For example, imagine that for some reason we need our employees to have <code>&quot;employee_name&quot;</code> and <code>&quot;employee_id&quot;</code> instead of just <code>&quot;name&quot;</code> and <code>&quot;id&quot;</code>. In PLRelational, you can call the <code>renameAttributes</code> method and tell it to make those changes:</p>
<pre><code>let renamedEmployees = employees.renameAttributes([&quot;name&quot;: &quot;employee_name&quot;,
                                                   &quot;id&quot;: &quot;employee_id&quot;])
</code></pre><p>The result looks like this:</p>
<pre><code>employee_id  employee_name
1            Jane Doe     
2            John Smith   
</code></pre><p>A project lets you remove unneeded attributes. For example, if you just wanted a list of employee IDs but not their names, you can eliminate the names by projecting onto the <code>&quot;id&quot;</code> attribute:</p>
<pre><code>let employeeIDs = employees.project(&quot;id&quot;)

id
1 
2 
</code></pre><p>Note that relations are always sets, and each row is unique. If a projection creates multiple identical rows due to eliminating the attribute that makes them unique (in this example, that would be two employees who somehow have the same ID but different names) then those rows are coalesced.</p><h3>Joins</h3><p>A join combines two relations with different schemes, and produces a new relation whose scheme is the combination of the two. The contents of the relation come from matching up values within the rows on each side.</p><p>The fundamental operation is called an equijoin. An equijoin takes two relations and a list of attributes to match. It then produces rows by gluing together rows from the operands where the values of those attributes are the same on both sides.</p><p>Let's look at a quick example. Here's a relation containing equipment registered to our employees:</p>
<pre><code>let equipment = MakeRelation(
    [&quot;owner_id&quot;, &quot;serial_number&quot;, &quot;comment&quot;],
    [1,          &quot;88842&quot;,         &quot;Computer&quot;],
    [1,          &quot;123&quot;,           &quot;Mouse&quot;],
    [2,          &quot;X427A&quot;,         &quot;Car&quot;],
    [2,          &quot;FFG77&quot;,         &quot;Cordless drill&quot;],
    [2,          &quot;7&quot;,             &quot;Seven&quot;])
</code></pre><p>We have each owner's ID, but not their name. We can include the name by using the <code>equijoin</code> method and telling it to match <code>id</code> in <code>employees</code> to <code>owner_id</code> in <code>equipment</code>:</p>
<pre><code>let employeeEquipment = employees
    .equijoin(equipment, matching: [&quot;id&quot;: &quot;owner_id&quot;])
</code></pre><p>Pretty-printing this, we get:</p>
<pre><code>comment         id  name        owner_id  serial_number
Cordless drill  2   John Smith  2         FFG77        
Seven           2   John Smith  2         7            
Car             2   John Smith  2         X427A        
Mouse           1   Jane Doe    1         123          
Computer        1   Jane Doe    1         88842        
</code></pre><p>Note that the values in <code>id</code> and <code>owner_id</code> will always be identical here. We can eliminate this redundancy with a project:</p>
<pre><code>let employeeEquipment = employees
    .equijoin(equipment, matching: [&quot;id&quot;: &quot;owner_id&quot;])
    .project(dropping: [&quot;owner_id&quot;])

comment         id  name        serial_number
Seven           2   John Smith  7            
Cordless drill  2   John Smith  FFG77        
Computer        1   Jane Doe    88842        
Car             2   John Smith  X427A        
Mouse           1   Jane Doe    123          
</code></pre><p>A join is a special case of an equijoin, where the matching attributes are those attributes that both sides have in common. For example, we could replicate the above result by renaming <code>&quot;owner_id&quot;</code> to <code>&quot;id&quot;</code> and then doing a join:</p>
<pre><code>let employeeEquipment = employees
    .join(equipment.renameAttributes([&quot;owner_id&quot;: &quot;id&quot;]))

comment         id  name        serial_number
Seven           2   John Smith  7            
Cordless drill  2   John Smith  FFG77        
Computer        1   Jane Doe    88842        
Car             2   John Smith  X427A        
Mouse           1   Jane Doe    123          
</code></pre><p>Joins act a lot like a select, where the predicate involves matching values between two relations rather than a constant value in the predicate expression. Joins can be really useful for tracking a selection. For example, let's say you have a relation which contains the ID of the employee currently selected in your app's UI:</p>
<pre><code>let selectedEmployeeID = MakeRelation([&quot;id&quot;], [1])
</code></pre><p>You can get all information about the selected employee by joining this relation with <code>employees</code>:</p>
<pre><code>let selectedEmployee = selectedEmployeeID.join(employees)
</code></pre><p>You can then project that relation down to just the name so that you can bind it to a UI control that will show the currently selected employee's name:</p>
<pre><code>let selectedEmployeeName = selectedEmployee.project(&quot;name&quot;)
</code></pre><p>Pretty-printing this on our test data produces:</p>
<pre><code>name    
Jane Doe
</code></pre><h3>Wrapping Up</h3><p>A relation is a set of rows. A row is effectively a string-to-value dictionary, where the keys are attributes. All rows in a given relation have the same attributes. That set of attributes is called the relation's scheme.</p><p>Since relations are sets, they support basic set operations like union, intersection, and difference. They also support filtering in the form of the select operation.</p><p>Relation attributes can be manipulated by renaming them, and attributes can be removed by projecting the relation. This is useful to get different forms of a relation into different parts of your program.</p><p>Joins allow combining two relations with different schemes. They produce new rows by gluing together rows from the relations where those rows have matching values. The equijoin operation allows matching arbitrary pairs of attributes, while the join operation handles the common case of matching the attributes that exist in both relations.</p><p>PLRelational provides all of these operations, and more, as methods on the <code>Relation</code> type. These methods don't perform the work immediately, but rather produce a new <code>Relation</code> that represents the operation. The work is performed only when data is requested. To see it in action, check out PLRelational's tests, in particular the <code>RelationTests.swift</code> file, which has extensive examples of the various operations.</p><p><br/> <em><strong>Need help?</strong> Plausible Labs offers consulting services for software engineering. If you'd like some professional assistance, whether with PLRelational or for something entirely different, consider us. More information can be found on our <a href="../../../portfolio/index.html">consulting</a> page.</em></p>
                
            </div>

            

<div class="sidebar">
    <h3>The Plausible Blog<a href="../../index-2.html?feed=rss2"><img src="../../../assets/images/blog/feed-icon/index.png" width="20px" height="20px" alt="" /></a></h3>
    <p>
        Latest news and musings from the co-op.
    </p>
    <p class="twitter">
        Follow us: <a href="https://twitter.com/plausiblelabs">&#64;plausiblelabs</a>
    </p>

    <h3>Recent Articles</h3>
    <ul>
        
            <li>
                <a href="../../2019/09/12/plcrashreporter-stewardship-moving-to-microsoft/index.html">PLCrashReporter Stewardship Moving to Microsoft</a>
                <span class="archive_date">September 12, 2019</span>
            </li>
        
            <li>
                <a href="../../2017/12/14/a-new-home-for-voodoopad/index.html">A New Home for VoodooPad</a>
                <span class="archive_date">December 14, 2017</span>
            </li>
        
            <li>
                <a href="../../2017/10/03/plrelational-query-optimization/index.html">PLRelational: Query Optimization and Execution</a>
                <span class="archive_date">October 3, 2017</span>
            </li>
        
            <li>
                <a href="../../2017/09/28/build-with-plrelational-part-2/index.html">Let&#x27;s Build with PLRelational, Part 2</a>
                <span class="archive_date">September 28, 2017</span>
            </li>
        
            <li>
                <a href="../../2017/09/18/build-with-plrelational-part-1/index.html">Let&#x27;s Build with PLRelational, Part 1</a>
                <span class="archive_date">September 18, 2017</span>
            </li>
        
    </ul>
    <p class="archives">
        <a href="../../archive/index.html">Browse Archive</a>
    </p>

    <h3>More from Lab Members</h3>
    <ul class="blogRoll">
        <li>
            <a href="https://labonnesoupe.org/">Digital Things</a>
            <span class="blogRoll_author">from Chris Campbell</span>
        </li>
    </ul>
</div>
        </div>

        <br class="clearFloats" />

        

<nav class="paging-navigation" role="navigation">
    <div class="nav-links">
        
        
            <a class="prev page-numbers" href="../2/index.html">Previous</a>
        
        
        
            
                <a class="page-numbers" href="../1/index.html">1</a>
            
        
            
                <a class="page-numbers" href="../2/index.html">2</a>
            
        
            
                <span class="page-numbers current">3</span>
            
        
            
                <a class="page-numbers" href="../4/index.html">4</a>
            
        
            
                <a class="page-numbers" href="../5/index.html">5</a>
            
        
            
                <a class="page-numbers" href="../6/index.html">6</a>
            
        
            
                <a class="page-numbers" href="../7/index.html">7</a>
            
        
            
                <a class="page-numbers" href="../8/index.html">8</a>
            
        
            
                <a class="page-numbers" href="../9/index.html">9</a>
            
        
            
                <a class="page-numbers" href="../10/index.html">10</a>
            
        
            
                <a class="page-numbers" href="../11/index.html">11</a>
            
        

        
            <a class="next page-numbers" href="../4/index.html">Next</a>
        
        
    </div>
</nav>

        
    </div>

            </div>
        <footer>
            <div class="inner">
                Plausible Labs Cooperative, Inc. &copy; 2008 - 2021
            </div>
        </footer>
    </body>

<!-- Mirrored from plausible.coop/blog/page/3 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Nov 2021 23:09:37 GMT -->
</html>

